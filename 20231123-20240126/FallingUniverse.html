<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Falling Universe</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Honk&display=swap"
      rel="stylesheet"
    />
    <script src="three.min.js"></script>
  </head>

  <body style="background-color: black; font-family: Honk">
    <h3
      id="title"
      style="
        color: red;
        position: absolute;
        z-index: 99;
        left: 46%;
        top: 25%;
        font-size: 40px;
      "
    >
      Falling Universe
    </h3>
    <h3
      id="planet"
      style="
        color: red;
        position: absolute;
        z-index: 99;
        left: 49%;
        top: 25%;
        font-size: 20px;
      "
    ></h3>
    <button
      onclick="onStart()"
      type="button"
      id="start"
      style="
        position: absolute;
        z-index: 99;
        left: 50%;
        top: 50%;
        display: block;
        height: 90px;
        width: 120px;
        background-color: red;
        border-style: hidden;
        font-family: Honk;
      "
    >
      Spiel starten!
    </button>
    <button
      onclick="again()"
      type="button"
      id="again"
      style="
        position: absolute;
        display: block;
        z-index: 99;
        left: 20%;
        top: 20%;
        height: 90px;
        width: 120px;
        background-color: red;
        border-style: hidden;
        font-family: Honk;
      "
    >
      Erneut spielen
    </button>
    <p
      id="zeit"
      style="z-index: 99; position: absolute; left: 30%; top: 30%"
    ></p>
    <p
      id="gewonnen"
      style="
        z-index: 99;
        position: absolute;
        left: 50%;
        font-size: 30px;
        top: 30%;
      "
    >
      GEWONNEN
    </p>

    <div id="myCanvas"></div>
  </body>

  <script>
    // Hier ist die Szenerie, in der sich alles abspielt:
    const textureLoader = new THREE.TextureLoader();
    const baumstamm = textureLoader.load('/baumrinde.jpg');
    const leaf = textureLoader.load('/leaf.jpg');
    const mond = textureLoader.load('/mond.jpg');
    const mars = textureLoader.load('/mars.jpg');
    const erde = textureLoader.load('/erde.jpg');
    const venus = textureLoader.load('/venus.jpg');
    const pluto = textureLoader.load('/pluto.jpg');
    const neptun = textureLoader.load('/neptun.jpg');
    const goaltexture = new THREE.MeshBasicMaterial({
      map: textureLoader.load('/goal.jpg'),
    });

    var materials = [
      new THREE.MeshBasicMaterial({ map: pluto }),
      new THREE.MeshBasicMaterial({ map: mond }),
      new THREE.MeshBasicMaterial({ map: mars }),
      new THREE.MeshBasicMaterial({ map: venus }),
      new THREE.MeshBasicMaterial({ map: erde }),
      new THREE.MeshBasicMaterial({ map: neptun }),
    ];

    var scene = new THREE.Scene();
    const groundBox = new THREE.BoxGeometry(100000, 0, 100000);
    const ground = new THREE.Mesh(groundBox, new THREE.MeshBasicMaterial());
    ground.position.set(0, -200, 0);
    scene.add(ground);

    scene.background = new THREE.Color(0x000000);
    const chrom = new THREE.MeshBasicMaterial({
      map: textureLoader.load('/chrom.jpg'),
    });
    // Hier steht die Kamera:
    var aspect_ratio = window.innerWidth / window.innerHeight;

    var camera = new THREE.PerspectiveCamera(75, aspect_ratio, 1, 10000);
    var angle = Math.PI / 12;
    camera.rotation.x += angle;

    var renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);

    document.getElementById('myCanvas').appendChild(renderer.domElement);

    const zAxis = new THREE.Vector3(0, 0, 1);
    const yAxis = new THREE.Vector3(0, 1, 0);
    const xAxis = new THREE.Vector3(1, 0, 0);

    const bellySize = 100;
    const handAngle = 30;
    const footAngle = -40;

    var step = 0.1 * bellySize;
    var rotstep = (4 * 2 * Math.PI) / 360;

    var headSize = bellySize * 0.5;
    var footSize = bellySize * 0.3;
    var handSize = bellySize * 0.2;

    var shapeHead = new THREE.SphereGeometry(headSize, 20, 15);
    var shapeBelly = new THREE.SphereGeometry(bellySize, 20, 15);
    var shapeHands = new THREE.SphereGeometry(handSize, 20, 15);
    var shapeFeet = new THREE.SphereGeometry(footSize, 20, 15);

    var belly = new THREE.Mesh(shapeBelly, chrom);
    const boxbelly = new THREE.Box3().setFromObject(belly);
    belly.position.set(0, 0, 0);
    scene.add(belly);

    // Kopf
    var head = new THREE.Mesh(shapeHead, chrom);
    head.position.set(0, bellySize + headSize - 10, 0);
    belly.add(head);

    // H채nde
    var hand1 = new THREE.Mesh(shapeHands, chrom);

    var h1pos = new THREE.Vector3(bellySize + handSize - 4, 0, 0);

    h1pos.applyAxisAngle(zAxis, ((2 * Math.PI) / 360) * (180 - handAngle));
    hand1.position.copy(h1pos);

    belly.add(hand1);

    var hand2 = new THREE.Mesh(shapeHands, chrom);
    var h2pos = new THREE.Vector3(bellySize + handSize - 4, 0, 0);
    var rotMat2 = new THREE.Matrix3();
    rotMat2.makeRotation(((2 * Math.PI) / 360) * handAngle);
    h2pos.applyMatrix3(rotMat2);
    hand2.position.copy(h2pos);
    belly.add(hand2);

    camera.position.set(0, -20, 400);
    head.add(camera);

    // B채ume
    const treeNum = 200;
    var trees = new Array(treeNum);

    for (let i = 0; i < treeNum; i += 2) {
      trees[i] = makeTreeAt(500, -100 * i);
      trees[i + 1] = makeTreeAt(-500, -100 * i);
    }

    for (let i = 0; i < treeNum; i++) {
      scene.add(trees[i]);
    }

    function removeElem(id) {
      var elem = document.getElementById(id);
      elem.parentNode.removeChild(elem);
    }
    const buttonStart = document.getElementById('start');
    const parentButtonStart = buttonStart.parentNode;
    const title = document.getElementById('title');
    const parentTitle = title.parentNode;

    function onStart() {
      renderer.render(scene, camera);
      parentButtonStart.removeChild(buttonStart);
      parentTitle.removeChild(title);
      gameLoop();
    }

    const canvas = document.getElementById('myCanvas');
    const parentCanvas = buttonStart.parentNode;

    function onEnd() {
      end = true;
      parentButtonStart.appendChild(buttonStart);
      parentCanvas.removeChild(canvas);
    }

    var keymap = {};
    onkeydown = onkeyup = function (e) {
      e = e || event; // to deal with IE
      keymap[e.keyCode] = e.type == 'keydown';
    };

    const clock = new THREE.Clock();

    var bool = false;
    function wait(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }

    function reset() {
      camera.position.set(0, -20, 400);
      belly.position.set(0, 0, 0);
      boxbelly.setFromObject(belly);
      timer = clock.getElapsedTime();
      keymap = {};
    }

    const boxarr = [];
    const ballarr = [];
    const planettext = document.getElementById('planet');
    async function detectCollisions() {
      for (i = 0; i < boxarr.length; i++) {
        if (boxbelly.intersectsBox(boxarr[i])) {
          reset();
        }
      }
      await wait(20);
    }

    var meter = 0.1;
    const g_pluto = 0.62 * meter;
    const g_mond = 1.62 * meter;
    const g_mars = 3.71 * meter;
    const g_venus = 8.87 * meter;
    const g_erde = 9.81 * meter;
    const g_neptun = 11.15 * meter;
    var Hoehe = 3 * meter;
    const gconstarr = [g_pluto, g_mond, g_mars, g_venus, g_erde, g_neptun];
    const gconstarrNames = ['Pluto', 'Mond', 'Mars', 'Venus', 'Erde', 'Neptun'];

    const speedarr = [];

    async function fall() {
      const t = clock.getElapsedTime();

      for (i = 0; i < ballarr.length; i++) {
        const tball = clock.getElapsedTime() - starttimes[i];
        speedarr[i] = speedarr[i] + g_const * tball;
        ballarr[i].position.y = ballarr[i].position.y - speedarr[i] * tball;
        boxarr[i].setFromObject(ballarr[i]);
        renderer.render(scene, camera);
        boxbelly.setFromObject(belly);
      }
    }
    const starttimes = [];
    var lasttime = 0;
    const startingspeed = 0.5;
    async function generateBoxes() {
      const timer = 1;
      if (clock.getElapsedTime() < lasttime + timer) {
        return;
      }
      lasttime += timer;
      for (let i = 0; i < 1; i++) {
        const shape = new THREE.BoxGeometry(100, 100, 100);
        const cover = currentmaterial;

        // Random position within a range
        const posX = Math.random() * 400 - 200 + belly.position.x; // Adjust the range as needed
        const posY = Math.random() * 200 + 300; // Adjust the range as needed
        const posZ = Math.random() * 200 - 650 + belly.position.z; // Adjust the range as needed

        const ball = new THREE.Mesh(shape, cover);
        const box = new THREE.Box3().setFromObject(ball);

        ball.position.set(posX, posY, posZ);
        scene.add(ball);
        speedarr.push(startingspeed);
        starttimes.push(clock.getElapsedTime());
        ballarr.push(ball);
        boxarr.push(box);
      }
    }

    async function clearground() {
      for (let i = 0; i < ballarr.length; i++) {
        if (ballarr[i].position.y < 0) {
          scene.remove(ballarr[i]);
          speedarr.splice(i, 1);
          boxarr.splice(i, 1);
          starttimes.splice(i, 1);
          ballarr.splice(i, 1); // Entfernt das Element aus dem Array
          i--; // Reduziert i, um das 체bersprungene Element zu ber체cksichtigen
        }
      }
    }

    function win() {
      parentagain.appendChild(buttonagain);
      parentwin.appendChild(pwin);
      end = true;
    }

    function again() {
      reset();
      parentagain.removeChild(buttonagain);
      parentwin.removeChild(pwin);
      gameLoop();
    }

    const goalshape = new THREE.BoxGeometry(800, 400, 400);
    const goalcover = new THREE.MeshBasicMaterial({ color: 0x098233 });
    const goal = new THREE.Mesh(goalshape, goaltexture);
    goal.position.set(0, 100, -12000);
    const goalbox = new THREE.Box3().setFromObject(goal);
    scene.add(goal);

    let timer = 0;
    const zeit = 30;
    const p = document.getElementById('zeit');
    async function positionCheck() {
      if (belly.position.x > 400 || belly.position.x < -400) {
        reset();
        return;
      }
      if (timer + zeit < clock.getElapsedTime()) {
        reset();
        return;
      }
      if (boxbelly.intersectsBox(goalbox)) {
        win();
      }
      p.innerText = Math.ceil(timer - clock.getElapsedTime() + zeit);
    }

    const buttonagain = document.getElementById('again');
    const parentagain = buttonagain.parentNode;
    parentagain.removeChild(buttonagain);
    const pwin = document.getElementById('gewonnen');
    const parentwin = pwin.parentNode;
    parentwin.removeChild(pwin);
    var end = false;
    let currentmaterial = materials[0];

    async function gameLoop() {
      const index = Math.floor(Math.random() * gconstarr.length);
      g_const = gconstarr[index];
      planettext.innerText = gconstarrNames[index];
      currentmaterial = materials[index];
      ground.material = currentmaterial;
      lasttime = 0;
      timer = 0;
      clock.start();
      end = false;
      while (true) {
        await generateBoxes();
        await pressed();
        await positionCheck();
        detectCollisions();
        fall();
        await clearground();
        if (end) break;
      }
    }
    async function pressed() {
      var tmpVec = new THREE.Vector3();
      if (keymap[65]) belly.position.x -= step; // 65
      if (keymap[68]) belly.position.x += step; // 68
      if (keymap[87]) {
        belly.getWorldDirection(tmpVec);
        belly.position.add(tmpVec.multiplyScalar(-step * 1.5));
      }
      if (keymap[83]) {
        belly.getWorldDirection(tmpVec);
        belly.position.add(tmpVec.multiplyScalar(step * 1.5));
      }
      boxbelly.setFromObject(belly);
      renderer.render(scene, camera);
      await wait(20);
    }

    function makeTreeAt(x, z) {
      var colorArr = [0xffff9f, 0xfa8791, 0xfefa12];
      var currentcolor = colorArr[Math.floor(Math.random() * 3)];
      var trunkBase = -75;
      var topPosition = 175;
      var trunk = new THREE.Mesh(
        new THREE.CylinderGeometry(50, 50, 200),
        new THREE.MeshBasicMaterial({
          map: baumstamm,
        })
      );
      var top = new THREE.Mesh(
        new THREE.SphereGeometry(150),
        new THREE.MeshBasicMaterial({ map: leaf })
      );
      top.position.y = topPosition;
      trunk.add(top);
      trunk.position.set(x, trunkBase, z);

      return trunk;
    }
  </script>
</html>
